I²C (Inter-Integrated Circuit), pronounced I-squared-C, is a synchronous, multi-master, multi-slave, packet switched, single-ended, serial computer bus invented in 1982 by Philips Semiconductor (now NXP Semiconductors). It is widely used for attaching lower-speed peripheral ICs to processors and microcontrollers in short-distance, intra-board communication. Alternatively I²C is spelled I2C (pronounced I-two-C) or IIC (pronounced I-I-C).
Since October 10, 2006, no licensing fees are required to implement the I²C protocol. However, fees are required to obtain I²C slave addresses allocated by NXP.Several competitors, such as Siemens AG (later Infineon Technologies AG, now Intel mobile communications), NEC, Texas Instruments, STMicroelectronics (formerly SGS-Thomson), Motorola (later Freescale, now merged with NXP), Nordic Semiconductor and Intersil, have introduced compatible I²C products to the market since the mid-1990s.
System Management Bus (SMBus), defined by Intel in 1995, is a subset of I²C, defining a stricter usage. One purpose of SMBus is to promote robustness and interoperability. Accordingly, modern I²C systems incorporate some policies and rules from SMBus, sometimes supporting both I²C and SMBus, requiring only minimal reconfiguration either by commanding or output pin use.



I²C is appropriate for peripherals where simplicity and low manufacturing cost are more important than speed. Common applications of the I²C bus are:

Describing connectable devices via small ROM configuration tables to enable "plug and play" operation, such as
Serial Presence Detect (SPD) EEPROMs on dual in-line memory modules (DIMMs), and
Extended Display Identification Data (EDID) for monitors via VGA, DVI and HDMI connectors.
System management for PC systems via SMBus;
SMBus pins are allocated in both Conventional PCI and PCI Express connectors.
Accessing real-time clocks and NVRAM chips that keep user settings.
Accessing low-speed DACs and ADCs.
Changing contrast, hue, and color balance settings in monitors (via Display Data Channel).
Changing sound volume in intelligent speakers.
Controlling small (e.g. feature phone) OLED or LCD displays.
Reading hardware monitors and diagnostic sensors, e.g. a fan's speed.
Turning on and turning off the power supply of system components.A particular strength of I²C is the capability of a microcontroller to control a network of device chips with just two general-purpose I/O pins and software. Many other bus technologies used in similar applications, such as Serial Peripheral Interface Bus (SPI), require more pins and signals to connect multiple devices.


The history of I²C specification releases:

In 1982, the original 100 kbit/s I²C system was created as a simple internal bus system for building control electronics with various Philips chips.
In 1992, Version 1 added 400 kbit/s Fast-mode (Fm) and a 10-bit addressing mode to increase capacity to 1008 nodes. This was the first standardized version.
In 1998, Version 2 added 3.4 Mbit/s High-speed mode (Hs) with power-saving requirements for electric voltage and current.
In 2000, Version 2.1 clarified version 2, without significant functional changes.
In 2007, Version 3 added 1 Mbit/s Fast-mode plus (Fm+) (using 20 mA drivers), and a device ID mechanism.
In 2012, Version 4 added 5 Mbit/s Ultra Fast-mode (UFm) for new USDA (data) and USCL (clock) lines using push-pull logic without pull-up resistors, and added an assigned manufacturer ID table. It is only a unidirectional bus.
In 2012, Version 5 corrected mistakes.
In 2014, Version 6 corrected two graphs. This is the most recent standard.



I²C uses only two bidirectional open collector or open drain lines, Serial Data Line (SDA) and Serial Clock Line (SCL), pulled up with resistors. Typical voltages used are +5 V or +3.3 V, although systems with other voltages are permitted.
The I²C reference design has a 7-bit address space, with a rarely-used 10-bit extension. Common I²C bus speeds are the 100 kbit/s standard mode and the 400 kbit/s Fast mode. There is also a 10 kbit/s low-speed mode, but arbitrarily low clock frequencies are also allowed. Recent revisions of I²C can host more nodes and run at faster speeds (400 kbit/s Fast mode, 1 Mbit/s Fast mode plus, 3.4 Mbit/s High Speed mode, and 5 Mbit/s Ultra Fast-mode). These speeds are more widely used on embedded systems than on PCs.
Note the bit rates are quoted for the transfers between master and slave without clock stretching or other hardware overhead. Protocol overheads include a slave address and perhaps a register address within the slave device, as well as per-byte ACK/NACK bits. Thus the actual transfer rate of user data is lower than those peak bit rates alone would imply. For example, if each interaction with a slave inefficiently allows only 1 byte of data to be transferred, the data rate will be less than half the peak bit rate.
The number of nodes which can exist on a given I²C bus is limited by the address space and also by the total bus capacitance of 400 pF, which restricts practical communication distances to a few meters. The relatively high impedance and low noise immunity requires a common ground potential, which again restricts practical use to communication within the same PC board or small system of boards.


The aforementioned reference design is a bus with a clock (SCL) and data (SDA) lines with 7-bit addressing. The bus has two roles for nodes: master and slave:

Master node – node that generates the clock and initiates communication with slaves.
Slave node – node that receives the clock and responds when addressed by the master.The bus is a multi-master bus, which means that any number of master nodes can be present. Additionally, master and slave roles may be changed between messages (after a STOP is sent).
There may be four potential modes of operation for a given bus device, although most devices only use a single role and its two modes:

master – master node is sending data to a slave,
master receive – master node is receiving data from a slave,
slave transmit – slave node is sending data to the master,
slave receive – slave node is receiving data from the master.In addition to 0 and 1 data bits, the I²C bus allows special START and STOP signals which act as message delimiters and are distinct from the data bits. (This is in contrast to the start bits and stop bits used in asynchronous serial communication, which are distinguished from data bits only by their timing.)
The master is initially in master transmit mode by sending a START followed by the 7-bit address of the slave it wishes to communicate with, which is finally followed by a single bit representing whether it wishes to write (0) to or read (1) from the slave.
If the slave exists on the bus then it will respond with an ACK bit (active low for acknowledged) for that address. The master then continues in either transmit or receive mode (according to the read/write bit it sent), and the slave continues in the complementary mode (receive or transmit, respectively).
The address and the data bytes are sent most significant bit first. The start bit is indicated by a high-to-low transition of SDA with SCL high; the stop bit is indicated by a low-to-high transition of SDA with SCL high. All other transitions of SDA take place with SCL low.
If the master wishes to write to the slave, then it repeatedly sends a byte with the slave sending an ACK bit. (In this situation, the master is in master transmit mode, and the slave is in slave receive mode.)
If the master wishes to read from the slave, then it repeatedly receives a byte from the slave, the master sending an ACK bit after every byte except the last one. (In this situation, the master is in master receive mode, and the slave is in slave transmit mode.)
An I²C transaction may consist of multiple messages. The master terminates a message with a STOP condition if this is the end of the transaction or it may send another START condition to retain control of the bus for another message (a "combined format" transaction).


I²C defines basic types of transactions, each of which begins with a START and ends with a STOP:

Single message where a master writes data to a slave.
Single message where a master reads data from a slave.
Combined format, where a master issues at least two reads or writes to one or more slaves.In a combined transaction, each read or write begins with a START and the slave address. The START conditions after the first are also called repeated START bits. Repeated STARTs are not preceded by STOP conditions, which is how slaves know that the next message is part of the same transaction.
Any given slave will only respond to certain messages, as specified in its product documentation.
Pure I²C systems support arbitrary message structures. SMBus is restricted to nine of those structures, such as read word N and write word N, involving a single slave. PMBus extends SMBus with a Group protocol, allowing multiple such SMBus transactions to be sent in one combined message. The terminating STOP indicates when those grouped actions should take effect. For example, one PMBus operation might reconfigure three power supplies (using three different I²C slave addresses), and their new configurations would take effect at the same time: when they receive that STOP.
With only a few exceptions, neither I²C nor SMBus define message semantics, such as the meaning of data bytes in messages. Message semantics are otherwise product-specific. Those exceptions include messages addressed to the I²C general call address (0x00) or to the SMBus Alert Response Address; and messages involved in the SMBus Address Resolution Protocol (ARP) for dynamic address allocation and management.
In practice, most slaves adopt request-response control models, where one or more bytes following a write command are treated as a command or address. Those bytes determine how subsequent written bytes are treated or how the slave responds on subsequent reads. Most SMBus operations involve single-byte commands.


One specific example is the 24C32 type EEPROM, which uses two request bytes that are called Address High and Address Low. (Accordingly, these EEPROMs are not usable by pure SMBus hosts, which only support single-byte commands or addresses.) These bytes are used for addressing bytes within the 32 kbit (or 4 kB) EEPROM address space. The same two-byte addressing is also used by larger EEPROMs, like the 24C512 which stores 512 kbits (or 64 kB). Writing and reading data to these EEPROMs uses a simple protocol: the address is written, and then data is transferred until the end of the message. The data transfer part protocol can cause trouble on the SMBus, since the data bytes are not preceded by a count, and more than 32 bytes can be transferred at once. I²C EEPROMs smaller than 32 kbit, like the 2 kbit 24C02, are often used on the SMBus with inefficient single-byte data transfers to overcome this problem.
A single message writes to the EEPROM. After the START, the master sends the chip's bus address with the direction bit clear (write), then sends the two-byte address of data within the EEPROM and then sends data bytes to be written starting at that address, followed by a STOP. When writing multiple bytes, all the bytes must be in the same 32-byte page. While it is busy saving those bytes to memory, the EEPROM will not respond to further I²C requests. (That is another incompatibility with SMBus: SMBus devices must always respond to their bus addresses.)
To read starting at a particular address in the EEPROM, a combined message is used. After a START, the master first writes that chip's bus address with the direction bit clear (write) and then the two bytes of EEPROM data address. It then sends a (repeated) START and the EEPROM's bus address with the direction bit set (read). The EEPROM will then respond with the data bytes beginning at the specified EEPROM data address — a combined message: first a write, then a read. The master issues an ACK after each read byte except the last byte, and then issues a STOP. The EEPROM increments the address after each data byte transferred; multi-byte reads can retrieve the entire contents of the EEPROM using one combined message.


At the physical layer, both SCL and SDA lines are of open-drain design, thus pull-up resistors are needed. A logic "0" is output by pulling the line to ground, and a logic "1" is output by letting the line float (output high impedance) so that the pull-up resistor pulls it high. A line is never actively driven high. This wiring allows multiple nodes to connect to the bus without short circuits from signal contention. High-speed systems (and some others) may use a current source instead of a resistor to pull-up on SCL or both SCL and SDA, to accommodate higher bus capacitance and enable faster rise times.
An important consequence of this is that multiple nodes may be driving the lines simultaneously. If any node is driving the line low, it will be low. Nodes that are trying to transmit a logical one (i.e. letting the line float high) can detect this and conclude that another node is active at the same time.
When used on SCL, this is called clock stretching and used as a flow-control mechanism for slaves. When used on SDA, this is called arbitration and ensures that there is only one transmitter at a time.
When idle, both lines are high. To start a transaction, SDA is pulled low while SCL remains high. It is illegal:14 to transmit a stop marker by releasing SDA to float high again (although such a "void message" is usually harmless), so the next step is to pull SCL low.
Except for the start and stop signals, the SDA line only changes while the clock is low; transmitting a data bit consists of pulsing the clock line high while holding the data line steady at the desired level.
While SCL is low, the transmitter (initially the master) sets SDA to the desired value and (after a small delay to let the value propagate) lets SCL float high. The master then waits for SCL to actually go high; this will be delayed by the finite rise time of the SCL signal (the RC time constant of the pull-up resistor and the parasitic capacitance of the bus) and may be additionally delayed by a slave's clock stretching.
Once SCL is high, the master waits a minimum time (4 μs for standard-speed I²C) to ensure that the receiver has seen the bit, then pulls it low again. This completes transmission of one bit.
After every 8 data bits in one direction, an "acknowledge" bit is transmitted in the other direction. The transmitter and receiver switch roles for one bit, and the original receiver transmits a single "0" bit (ACK) back. If the transmitter sees a "1" bit (NACK) instead, it learns that:

(If master transmitting to slave) The slave is unable to accept the data. No such slave, command not understood, or unable to accept any more data.
(If slave transmitting to master) The master wishes the transfer to stop after this data byte.Only the SDA line changes direction during acknowledge bits; the SCL is always controlled by the master.
After the acknowledge bit, the clock line is low and the master may do one of three things:

Begin transferring another byte of data: the transmitter sets SDA, and the master pulses SCL high.
Send a "Stop": Set SDA low, let SCL go high, then let SDA go high. This releases the I²C bus.
Send a "Repeated start": Set SDA high, let SCL go high, then pull SDA low again. This starts a new I²C bus message without releasing the bus.


One of the more significant features of the I²C protocol is clock stretching. An addressed slave device may hold the clock line (SCL) low after receiving (or sending) a byte, indicating that it is not yet ready to process more data. The master that is communicating with the slave may not finish the transmission of the current bit, but must wait until the clock line actually goes high. If the slave is clock-stretching, the clock line will still be low (because the connections are open-drain). The same is true if a second, slower, master tries to drive the clock at the same time. (If there is more than one master, all but one of them will normally lose arbitration.)
The master must wait until it observes the clock line going high, and an additional minimal time (4 μs for standard 100 kbit/s I²C) before pulling the clock low again.
Although the master may also hold the SCL line low for as long as it desires (this is not allowed in newest Rev. 6 of the protocol – subsection 3.1.1), the term "clock stretching" is normally used only when slaves do it. Although in theory any clock pulse may be stretched, generally it is the intervals before or after the acknowledgment bit which are used. For example, if the slave is a microcontroller, its I²C interface could stretch the clock after each byte, until the software decides whether to send a positive acknowledgment or a NACK.
Clock stretching is the only time in I²C where the slave drives SCL. Many slaves do not need to clock stretch and thus treat SCL as strictly an input with no circuitry to drive it. Some masters, such as those found inside custom ASICs may not support clock stretching; often these devices will be labeled as a "two-wire interface" and not I²C.
To ensure a minimal bus throughput, SMBus places limits on how far clocks may be stretched. Hosts and slaves adhering to those limits cannot block access to the bus for more than a short time, which is not a guarantee made by pure I²C systems.


Every master monitors the bus for start and stop bits and does not start a message while another master is keeping the bus busy. However, two masters may start transmission at about the same time; in this case, arbitration occurs. Slave transmit mode can also be arbitrated, when a master addresses multiple slaves, but this is less common. In contrast to protocols (such as Ethernet) that use random back-off delays before issuing a retry, I²C has a deterministic arbitration policy. Each transmitter checks the level of the data line (SDA) and compares it with the levels it expects; if they do not match, that transmitter has lost arbitration and drops out of this protocol interaction.
If one transmitter sets SDA to 1 (not driving a signal) and a second transmitter sets it to 0 (pull to ground), the result is that the line is low. The first transmitter then observes that the level of the line is different from that expected and concludes that another node is transmitting. The first node to notice such a difference is the one that loses arbitration: it stops driving SDA. If it is a master, it also stops driving SCL and waits for a STOP; then it may try to reissue its entire message. In the meantime, the other node has not noticed any difference between the expected and actual levels on SDA and therefore continues transmission. It can do so without problems because so far the signal has been exactly as it expected; no other transmitter has disturbed its message.
If the two masters are sending a message to two different slaves, the one sending the lower slave address always "wins" arbitration in the address stage. Since the two masters may send messages to the same slave address, and addresses sometimes refer to multiple slaves, arbitration must continue into the data stages.
Arbitration occurs very rarely, but is necessary for proper multi-master support. As with clock stretching, not all devices support arbitration. Those that do, generally label themselves as supporting "multi-master" communication.
One case which must be handled carefully in multi-master I²C implementations is that of the masters talking to each other. One master may lose arbitration to an incoming message, and must change its role from master to slave in time to acknowledge its own address.
In the extremely rare case that two masters simultaneously send identical messages, both will regard the communication as successful, but the slave will only see one message. For this reason, when a slave can be accessed by multiple masters, every command recognized by the slave either must be idempotent or must be guaranteed never to be issued by two masters at the same time. (For example, a command which is issued by only one master need not be idempotent, nor is it necessary for a specific command to be idempotent when some mutual exclusion mechanism ensures that only one master can be caused to issue that command at any given time.)


While I²C only arbitrates between masters, SMBus uses arbitration in three additional contexts, where multiple slaves respond to the master, and one gets its message through.

Although conceptually a single-master bus, a slave device that supports the "host notify protocol" acts as a master to perform the notification. It seizes the bus and writes a 3-byte message to the reserved "SMBus Host" address (0x08), passing its address and two bytes of data. When two slaves try to notify the host at the same time, one of them will lose arbitration and need to retry.
An alternative slave notification system uses the separate SMBALERT# signal to request attention. In this case, the host performs a 1-byte read from the reserved "SMBus Alert Response Address" (0x0C), which is a kind of broadcast address. All alerting slaves respond with a data bytes containing their own address. When the slave successfully transmits its own address (winning arbitration against others) it stops raising that interrupt. In both this and the preceding case, arbitration ensures that one slave's message will be received, and the others will know they must retry.
SMBus also supports an "address resolution protocol", wherein devices return a 16-byte "universal device ID" (UDID). Multiple devices may respond; the one with the lowest UDID will win arbitration and be recognized.


PMBus version 1.3 extends the SMBus alert response protocol in its "zone read" protocol. Slaves may be grouped into "zones", and all slaves in a zone may be addressed to respond, with their responses masked (omitting unwanted information), inverted (so wanted information is sent as 0 bits, which win arbitration), or reordered (so the most significant information is sent first). Arbitration ensures that the highest priority response is the one first returned to the master.
PMBus reserves I²C addresses 0x28 and 0x37 for zone reads and writes, respectively.


There are several possible operating modes for I²C communication. All are compatible in that the 100 kbit/s standard mode may always be used, but combining devices of different capabilities on the same bus can cause issues, as follows:

Fast mode is highly compatible and simply tightens several of the timing parameters to achieve 400 kbit/s speed. Fast mode is widely supported by I²C slave devices, so a master may use it as long as it knows that the bus capacitance and pull-up strength allow it.
Fast mode plus achieves up to 1 Mbit/s using more powerful (20 mA) drivers and pull-ups to achieve faster rise and fall times. Compatibility with standard and fast mode devices (with 3 mA pull-down capability) can be achieved if there is some way to reduce the strength of the pull-ups when talking to them.
High speed mode (3.4 Mbit/s) is compatible with normal I²C devices on the same bus, but requires the master have an active pull-up on the clock line which is enabled during high speed transfers. The first data bit is transferred with a normal open-drain rising clock edge, which may be stretched. For the remaining seven data bits, and the ACK, the master drives the clock high at the appropriate time and the slave may not stretch it. All high-speed transfers are preceded by a single-byte "master code" at fast/standard speed. This code serves three purposes:
it tells high-speed slave devices to change to high-speed timing rules,
it ensures that fast/normal speed devices will not try to participate in the transfer (because it does not match their address), and
because it identifies the master (there are eight master codes, and each master must use a different one), it ensures that arbitration is complete before the high-speed portion of the transfer, and so the high-speed portion need not make allowances for that ability.
Ultra-Fast mode is essentially a write-only I²C subset, which is incompatible with other modes except in that it is easy to add support for it to an existing I²C interface hardware design. Only one master is permitted, and it actively drives both clock and data lines at all times to achieve a 5 Mbit/s transfer rate. Clock stretching, arbitration, read transfers, and acknowledgements are all omitted. It is mainly intended for animated LED displays where a transmission error would only cause an inconsequential brief visual glitch. The resemblance to other I²C bus modes is limited to:
the start and stop conditions are used to delimit transfers,
I²C addressing allows multiple slave devices to share the bus without SPI bus style slave select signals, and
a ninth clock pulse is sent per byte transmitted marking the position of the unused acknowledgement bits.In all modes, the clock frequency is controlled by the master(s), and a longer-than-normal bus may be operated at a slower-than-nominal speed by underclocking.


I²C is popular for interfacing peripheral circuits to prototyping systems, such as the Arduino and Raspberry Pi. I²C does not employ a standardized connector, however, board designers have created various wiring schemes for I²C interconnections. To minimize the possible damage due to plugging 0.1-inch headers in backwards, some developers have suggested using alternating signal and power connections of the following wiring schemes: (GND, SCL, VCC, SDA) or (VCC, SDA, GND, SCL).The vast majority of applications use I²C in the way it was originally designed—peripheral ICs directly wired to a processor on the same printed circuit board, and therefore over relatively short distances of less than a foot, without a connector.
However a few applications use I²C to communicate between two boards, in some cases over a dozen meters apart, using pairs of I²C bus buffers to boost the signal or re-encode it as a differential signal traveling over CAT5 or other cable.Several standard connectors carry I²C signals. For example, the UEXT connector carries I²C;
the 10-pin iPack connector carries I²C; the 6P6C Lego Mindstorms NXT connector carries I²C; a few people use the 8P8C connectors and CAT5 cable normally used for Ethernet physical layer to instead carry differential-encoded I²C signals or boosted single-ended I²C signals; and every HDMI and most DVI and VGA connectors carry DDC2 data over I²C.


When there are many I²C devices in a system, there can be a need to include bus buffers or multiplexers to split large bus segments into smaller ones. This can be necessary to keep the capacitance of a bus segment below the allowable value or to allow multiple devices with the same address to be separated by a multiplexer. Many types of multiplexers and buffers exist and all must take into account the fact that I²C lines are specified to be bidirectional. Multiplexers can be implemented with analog switches, which can tie one segment to another. Analog switches maintain the bidirectional nature of the lines but do not isolate the capacitance of one segment from another or provide buffering capability.
Buffers can be used to isolate capacitance on one segment from another and/or allow I²C to be sent over longer cables or traces. Buffers for bi-directional lines such as I²C must use one of several schemes for preventing latch-up. I²C is open-drain, so buffers must drive a low on one side when they see a low on the other. One method for preventing latch-up is for a buffer to have carefully selected input and output levels such that the output level of its driver is higher than its input threshold, preventing it from triggering itself. For example, a buffer may have an input threshold of 0.4 V for detecting a low, but an output low level of 0.5 V. This method requires that all other devices on the bus have thresholds which are compatible and often means that multiple buffers implementing this scheme cannot be put in series with one another.
Alternatively, other types of buffers exist that implement current amplifiers or keep track of the state (i.e. which side drove the bus low) to prevent latch-up. The state method typically means that an unintended pulse is created during a hand-off when one side is driving the bus low, then the other drives it low, then the first side releases (this is common during an I²C acknowledgement).


When having a single master, it is possible to have multiple I²C busses share the same SCL line. The packets on each bus are either sent one after the other or at the same time. This is possible, because the communication on each bus can be subdivided in alternating short periods with high SCL followed by short periods with low SCL. And the clock can be stretched, if one bus needs more time in one state.
Advantages are using slaves devices with the same address at the same time and saving connections or a faster throughput by using several data lines at the same time.


These tables show the various atomic states and bit operations that may occur during an I²C message.








Two groups of addresses are reserved for special functions:

0000 XXX
1111 XXXSMBus reserves some additional addresses. In particular, 0001 000 is reserved for the SMBus host, which may be used by master-capable devices, 0001 100 is the "SMBus alert response address" which is polled by the host after an out-of-band interrupt, and 1100 001 is the default address which is initially used by devices capable of dynamic address assignment.


Although MSB 1111 is reserved for Device ID and 10-bit slave addressing, it is also used by VESA DDC display dependent devices such as pointing devices.


An I²C transaction consists of one or more messages. Each message begins with a start symbol, and the transaction ends with a stop symbol. Start symbols after the first, which begin a message but not a transaction, are referred to as repeated start symbols.
Each message is a read or a write. A transaction consisting of a single message is called either a read or a write transaction. A transaction consisting of multiple messages is called a combined transaction. The most common form of the latter is a write message providing intra-device address information, followed by a read message.
Many I²C devices do not distinguish between a combined transaction and the same messages sent as separate transactions, but not all. The device ID protocol requires a single transaction; slaves are forbidden from responding if they observe a stop symbol. Configuration, calibration or self-test modes which cause the slave to respond unusually are also often automatically terminated at the end of a transaction.



Data transfer is initiated with a start bit (S) signaled by SDA being pulled low while SCL stays high.
SCL is pulled low, and SDA sets the first data bit level while keeping SCL low (during blue bar time).
The data are sampled (received) when SCL rises for the first bit (B1). For a bit to be valid, SDA must not change between a rising edge of SCL and the subsequent falling edge (the entire green bar time).
This process repeats, SDA transitioning while SCL is low, and the data being read while SCL is high (B2, ...Bn).
The final bit is followed by a clock pulse, during which SDA is pulled low in preparation for the stop bit.
A stop bit (P) is signaled when SCL rises, followed by SDA rising.In order to avoid false marker detection, there is a minimum delay between the SCL falling edge and changing SDA, and between changing SDA and the SCL rising edge. Note that an I²C message containing N data bits (including acknowledges) contains N+1 clock pulses.


Below is an example of bit-banging the I²C protocol as an I²C master. The example is written in pseudo C. It illustrates all of the I²C features described before (clock stretching, arbitration, start/stop bit, ack/nack).


In AmigaOS one can use the i2c.resource component for AmigaOS 4.x and MorphOS 3.x or the shared library i2c.library by Wilhelm Noeker for older systems.
Arduino developers can use the "Wire" library.
Maximite supports I²C communications natively as part of its MMBasic.
PICAXE uses the i2c and hi2c commands.
eCos supports I²C for several hardware architectures.
ChibiOS/RT supports I²C for several hardware architectures.
FreeBSD, NetBSD and OpenBSD also provide an I²C framework, with support for a number of common master controllers and sensors.
Since OpenBSD 3.9 (released 1 May 2006 (2006-05-01)), a central i2c_scan subsystem probes all possible sensor chips at once during boot, using an ad-hoc weighting scheme and a local caching function for reading register values from the I²C slaves; this makes it possible to probe sensors on general-purpose off-the-shelf i386/amd64 hardware during boot without any configuration by the user nor a noticeable probing delay; the matching procedures of the individual drivers then only has to rely on a string-based "friendly-name" for matching; as a result, most I²C sensor drivers are automatically enabled by default in applicable architectures without ill effects on stability; individual sensors, both I²C and otherwise, are exported to the userland through the sysctl hw.sensors framework.  As of March 2019, OpenBSD has over two dozen device drivers on I²C that export some kind of a sensor through the hw.sensors framework, and the majority of these drivers are fully enabled by default in i386/amd64 GENERIC kernels of OpenBSD.
In NetBSD, over two dozen of I²C slave devices exist that feature hardware monitoring sensors, which are accessible through the sysmon envsys framework as property lists.  On general-purpose hardware, each driver has to do its own probing, hence all drivers for the I²C slaves are disabled by default in NetBSD in GENERIC i386/amd64 builds.
In Linux, I²C is handled with a device driver for the specific device, and another for the I²C (or SMBus) adapter to which it is connected. Several hundred such drivers are part of current releases.
In Mac OS X, there are about two dozen I²C kernel extensions that communicate with sensors for reading voltage, current, temperature, motion, and other physical status.
In Microsoft Windows, I²C is implemented by the respective device drivers of much of the industry's available hardware.
Unison OS, a POSIX RTOS for IoT, supports I²C for several MCU and MPU hardware architectures.
In Windows CE, I²C is implemented by the respective device drivers of much of the industry's available hardware.
In RISC OS, I²C is provided with a generic I²C interface from the IO controller and supported from the OS module system
In Sinclair QDOS and Minerva QL operating systems I²C is supported by a set of extensions provided by TF Services.


When developing or troubleshooting systems using I²C, visibility at the level of hardware signals can be important.


There are a number of hardware solutions for host computers, running Linux, Mac or Windows, I²C master and/or slave capabilities. Most of them are based on USB-to-I²C adapters. Not all of them require proprietary drivers or APIs.


I²C protocol analyzers are tools that sample an I²C bus and decode the electrical signals to provide a higher-level view of the data being transmitted on the bus.


When developing and/or troubleshooting the I²C bus, examination of hardware signals can be very important. Logic analyzers are tools that collect, analyze, decode, and store signals, so people can view the high-speed waveforms at their leisure. Logic analyzers display time stamps of each signal level change, which can help find protocol problems. Most logic analyzers have the capability to decode bus signals into high-level protocol data and show ASCII data.


The assignment of slave addresses is one weakness of I²C. Seven bits is too few to prevent address collisions between the many thousands of available devices. What alleviates the issue of address collisions between different vendors and also allows to connect to several identical devices is that manufacturers dedicate pins that can be used to set the slave address to one of a few address options per device. Two or three pins is typical, and with many devices, there are three or more wiring options per address pin.10-bit I²C addresses are not yet widely used, and many host operating systems do not support them. Neither is the complex SMBus "ARP" scheme for dynamically assigning addresses (other than for PCI cards with SMBus presence, for which it is required).
Automatic bus configuration is a related issue. A given address may be used by a number of different protocol-incompatible devices in various systems, and hardly any device types can be detected at runtime. For example, 0x51 may be used by a 24LC02 or 24C32 EEPROM, with incompatible addressing; or by a PCF8563 RTC, which cannot reliably be distinguished from either (without changing device state, which might not be allowed). The only reliable configuration mechanisms available to hosts involve out-of-band mechanisms such as tables provided by system firmware, which list the available devices. Again, this issue can partially be addressed by ARP in SMBus systems, especially when vendor and product identifiers are used; but that has not really caught on. The rev. 03 version of the I²C specification adds a device ID mechanism.
I²C supports a limited range of speeds. Hosts supporting the multi-megabit speeds are rare. Support for the Fm+ 1 Mbit/s speed is more widespread, since its electronics are simple variants of what is used at lower speeds. Many devices do not support the 400 kbit/s speed (in part because SMBus does not yet support it). I²C nodes implemented in software (instead of dedicated hardware) may not even support the 100 kbit/s speed; so the whole range defined in the specification is rarely usable. All devices must at least partially support the highest speed used or they may spuriously detect their device address.
Devices are allowed to stretch clock cycles to suit their particular needs, which can starve bandwidth needed by faster devices and increase latencies when talking to other device addresses. Bus capacitance also places a limit on the transfer speed, especially when current sources are not used to decrease signal rise times.
Because I²C is a shared bus, there is the potential for any device to have a fault and hang the entire bus. For example, if any device holds the SDA or SCL line low, it prevents the master from sending START or STOP commands to reset the bus. Thus it is common for designs to include a reset signal that provides an external method of resetting the bus devices. However many devices do not have a dedicated reset pin, forcing the designer to put in circuitry to allow devices to be power-cycled if they need to be reset.
Because of these limits (address management, bus configuration, potential faults, speed), few I²C bus segments have even a dozen devices. It is common for systems to have several such segments. One might be dedicated to use with high-speed devices, for low-latency power management. Another might be used to control a few devices where latency and throughput are not important issues; yet another segment might be used only to read EEPROM chips describing add-on cards (such as the SPD standard used with DRAM sticks).


I²C is the basis for the ACCESS.bus, the VESA Display Data Channel (DDC) interface, the System Management Bus (SMBus), Power Management Bus (PMBus) and the Intelligent Platform Management Bus (IPMB, one of the protocols of IPMI). These variants have differences in voltage and clock frequency ranges, and may have interrupt lines.
High-availability systems (AdvancedTCA, MicroTCA) use 2-way redundant I²C for shelf management. Multi-master I²C capability is a requirement in these systems.
TWI (Two-Wire Interface) or TWSI (Two-Wire Serial Interface) is essentially the same bus implemented on various system-on-chip processors from Atmel and other vendors. Vendors use the name TWI, even though I²C is not a registered trademark as of 2014-11-07. Trademark protection only exists for the respective logo (see upper right corner), and patents on I²C have now lapsed.
In some cases, use of the term "two-wire interface" indicates incomplete implementation of the I²C specification. Not supporting arbitration or clock stretching is one common limitation, which is still useful for a single master communicating with simple slaves that never stretch the clock.
MIPI I3C sensor interface standard (I3C) is a development of I²C, under development in 2017.

